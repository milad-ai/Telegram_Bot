import os
import re
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update, Document
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext
from sqlalchemy import create_engine, text
from flask import Flask
from threading import Thread
import jdatetime
from datetime import datetime
import pytz

# ==================== ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ====================
TOKEN = os.environ.get("BOT_TOKEN")
DB_URI = os.environ.get("DB_URI")

if not TOKEN or not DB_URI:
    raise ValueError("BOT_TOKEN and DB_URI must be set!")

engine = create_engine(DB_URI)

majors = [["ÿπŸÑŸàŸÖ ⁄©ÿßŸÖŸæ€åŸàÿ™ÿ±"], ["ÿ¢ŸÖÿßÿ±"]]
hw_numbers = [["3", "4", "5", "6"]]

user_state = {}

welcome_text = (
    "ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ! ÿß€åŸÜ ÿ±ÿ®ÿßÿ™ ÿ®ÿ±ÿß€å ÿØÿ±ÿ≥ Ÿæÿß€å⁄ØÿßŸá ÿØÿßÿØŸá ÿØÿßŸÜÿ¥ÿ¨Ÿà€åÿßŸÜ ÿ∑ÿ±ÿßÿ≠€å ÿ¥ÿØŸá ÿßÿ≥ÿ™.\n\n"
    "üìã ÿ±ÿßŸáŸÜŸÖÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá:\n"
    "1Ô∏è‚É£ ÿ±ÿ¥ÿ™Ÿá ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ\n"
    "2Ô∏è‚É£ ŸÜÿßŸÖ Ÿà ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å Ÿà ÿ¥ŸÖÿßÿ±Ÿá ÿØÿßŸÜÿ¥ÿ¨Ÿà€å€å ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ\n"
    "3Ô∏è‚É£ ÿ¥ŸÖÿßÿ±Ÿá ÿ™ŸÖÿ±€åŸÜ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ (3ÿå 4ÿå 5ÿå 6)\n"
    "4Ô∏è‚É£ ⁄©ÿØ SQL ÿÆŸàÿØ ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ (ŸÖÿ™ŸÜ €åÿß ŸÅÿß€åŸÑ .sql)\n\n"
    "‚ö†Ô∏è ŸÇÿ®ŸÑ ÿßÿ≤ Ÿáÿ± ÿ≥ŸàÿßŸÑ ÿ≠ÿ™ŸÖÿßŸã ⁄©ÿßŸÖŸÜÿ™ # number X ÿ®⁄Øÿ∞ÿßÿ±€åÿØ\n"
)

# ==================== ÿ™Ÿàÿßÿ®ÿπ ⁄©ŸÖ⁄©€å ====================
def get_persian_datetime():
    tehran_tz = pytz.timezone('Asia/Tehran')
    now = datetime.now(tehran_tz)
    persian_date = jdatetime.datetime.fromgregorian(datetime=now)
    
    weekdays = ['ÿ¥ŸÜÿ®Ÿá', '€å⁄©ÿ¥ŸÜÿ®Ÿá', 'ÿØŸàÿ¥ŸÜÿ®Ÿá', 'ÿ≥Ÿá‚Äåÿ¥ŸÜÿ®Ÿá', '⁄ÜŸáÿßÿ±ÿ¥ŸÜÿ®Ÿá', 'ŸæŸÜÿ¨‚Äåÿ¥ŸÜÿ®Ÿá', 'ÿ¨ŸÖÿπŸá']
    months = ['ŸÅÿ±Ÿàÿ±ÿØ€åŸÜ', 'ÿßÿ±ÿØ€åÿ®Ÿáÿ¥ÿ™', 'ÿÆÿ±ÿØÿßÿØ', 'ÿ™€åÿ±', 'ŸÖÿ±ÿØÿßÿØ', 'ÿ¥Ÿáÿ±€åŸàÿ±',
              'ŸÖŸáÿ±', 'ÿ¢ÿ®ÿßŸÜ', 'ÿ¢ÿ∞ÿ±', 'ÿØ€å', 'ÿ®ŸáŸÖŸÜ', 'ÿßÿ≥ŸÅŸÜÿØ']
    
    return f"{weekdays[persian_date.weekday()]} {persian_date.day} {months[persian_date.month-1]} {persian_date.year}", \
           f"{persian_date.hour:02d}:{persian_date.minute:02d}:{persian_date.second:02d}"

def get_submission_count(student_id: str, hw: str) -> int:
    try:
        with engine.begin() as conn:
            result = conn.execute(
                text("SELECT COUNT(*) FROM student_results WHERE student_id = :student_id AND hw = :hw"),
                {"student_id": student_id, "hw": hw}
            ).fetchone()
            return result[0] if result else 0
    except Exception as e:
        print(f"Error getting submission count: {e}")
        return 0

def get_main_menu():
    return ReplyKeyboardMarkup([["ÿ™ŸÖÿ±€åŸÜ ÿ¨ÿØ€åÿØ"], ["Ÿæÿß€åÿßŸÜ"]], one_time_keyboard=True)

def get_hw_selection_menu():
    hw_with_back = hw_numbers + [["üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å"]]
    return ReplyKeyboardMarkup(hw_with_back, one_time_keyboard=True)

# ==================== ŸáŸÜÿØŸÑÿ±Ÿáÿß ====================
def start(update: Update, context: CallbackContext):
    chat_id = update.message.chat_id
    update.message.reply_text(welcome_text)
    user_state[chat_id] = "waiting_major"
    update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã ÿ±ÿ¥ÿ™Ÿá ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=ReplyKeyboardMarkup(majors, one_time_keyboard=True))

def handle_message(update: Update, context: CallbackContext):
    chat_id = update.message.chat_id
    text = update.message.text

    if text == "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å":
        user_state[chat_id] = "completed"
        update.message.reply_text("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å:", reply_markup=get_main_menu())
        return

    state = user_state.get(chat_id)

    if state == "waiting_major":
        if text in ["ÿπŸÑŸàŸÖ ⁄©ÿßŸÖŸæ€åŸàÿ™ÿ±", "ÿ¢ŸÖÿßÿ±"]:
            context.user_data["major"] = text
            user_state[chat_id] = "waiting_name"
            update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ Ÿà ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:", reply_markup=ReplyKeyboardRemove())
        else:
            update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ŸÖŸÜŸà ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.")

    elif state == "waiting_name":
        context.user_data["name"] = text.strip()
        user_state[chat_id] = "waiting_student_id"
        update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã ÿ¥ŸÖÿßÿ±Ÿá ÿØÿßŸÜÿ¥ÿ¨Ÿà€å€å ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")

    elif state == "waiting_student_id":
        context.user_data["student_id"] = text.strip()
        user_state[chat_id] = "waiting_hw"
        update.message.reply_text("ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ¥ŸÖÿß ÿ´ÿ®ÿ™ ÿ¥ÿØ. ÿ¥ŸÖÿßÿ±Ÿá ÿ™ŸÖÿ±€åŸÜ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=get_hw_selection_menu())

    elif state == "waiting_hw":
        if text in ["3", "4", "5", "6"]:
            student_id = context.user_data["student_id"]
            hw = text
            submission_count = get_submission_count(student_id, hw)
            if submission_count >= 10:
                update.message.reply_text(
                    f"‚ùå ÿ¥ŸÖÿß ŸÇÿ®ŸÑÿßŸã €±€∞ ÿ®ÿßÿ± ÿ™ŸÖÿ±€åŸÜ {hw} ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.\n"
                    "ŸÑÿ∑ŸÅÿßŸã ÿ™ŸÖÿ±€åŸÜ ÿØ€å⁄Øÿ±€å ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=get_hw_selection_menu())
                return
            context.user_data["hw"] = hw
            user_state[chat_id] = "waiting_sql"
            remaining_attempts = 10 - submission_count
            update.message.reply_text(
                f"ÿ™ŸÖÿ±€åŸÜ {hw} ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØ.\nüìä ÿ™ÿπÿØÿßÿØ ÿßÿ±ÿ≥ÿßŸÑ‚ÄåŸáÿß€å ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá: {remaining_attempts}\n"
                "ŸÑÿ∑ŸÅÿßŸã SQL ÿÆŸàÿØ ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ €åÿß ŸÅÿß€åŸÑ .sql ÿ®ŸÅÿ±ÿ≥ÿ™€åÿØ:",
                reply_markup=ReplyKeyboardMarkup([["üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å"]], one_time_keyboard=True)
            )
        else:
            update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã ÿ¥ŸÖÿßÿ±Ÿá ÿ™ŸÖÿ±€åŸÜ ŸÖÿπÿ™ÿ®ÿ± ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.")

    elif state == "waiting_sql":
        process_sql(update, context, text)

    elif state == "completed":
        if text == "ÿ™ŸÖÿ±€åŸÜ ÿ¨ÿØ€åÿØ":
            user_state[chat_id] = "waiting_hw"
            update.message.reply_text("ÿ¥ŸÖÿßÿ±Ÿá ÿ™ŸÖÿ±€åŸÜ ÿ¨ÿØ€åÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=get_hw_selection_menu())
        elif text == "Ÿæÿß€åÿßŸÜ":
            update.message.reply_text("ŸÖÿ™ÿ¥⁄©ÿ±ŸÖ! ÿ®ÿ±ÿß€å ÿ¥ÿ±Ÿàÿπ ÿØŸàÿ®ÿßÿ±Ÿá /start ÿ±ÿß ÿ®ÿ≤ŸÜ€åÿØ.", reply_markup=get_main_menu())
        else:
            update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ŸÖŸÜŸà ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.", reply_markup=get_main_menu())

def handle_document(update: Update, context: CallbackContext):
    chat_id = update.message.chat_id
    if user_state.get(chat_id) != "waiting_sql":
        update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã ŸÖÿ±ÿßÿ≠ŸÑ ÿ±ÿß ÿßÿ≤ /start ÿØŸÜÿ®ÿßŸÑ ⁄©ŸÜ€åÿØ.")
        return
    document: Document = update.message.document
    if not document.file_name.endswith(".sql"):
        update.message.reply_text("ŸÑÿ∑ŸÅÿßŸã €å⁄© ŸÅÿß€åŸÑ ŸÖÿπÿ™ÿ®ÿ± .sql ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ.",
                                  reply_markup=ReplyKeyboardMarkup([["üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà ÿßÿµŸÑ€å"]], one_time_keyboard=True))
        return
    file = document.get_file()
    sql_text = file.download_as_bytearray().decode("utf-8")
    process_sql(update, context, sql_text)

# ==================== Ÿæÿ±ÿØÿßÿ≤ÿ¥ SQL ====================
def process_sql(update: Update, context: CallbackContext, sql_text: str):
    chat_id = update.message.chat_id

    queries = re.split(r"#\s*number\s*\d+", sql_text, flags=re.IGNORECASE)
    queries = [q.strip() for q in queries if q.strip()]

    hw = context.user_data["hw"]
    name = context.user_data["name"]
    student_id = context.user_data["student_id"]
    major = context.user_data["major"]

    submission_count = get_submission_count(student_id, hw)
    if submission_count >= 10:
        update.message.reply_text(
            f"‚ùå ÿ¥ŸÖÿß ŸÇÿ®ŸÑÿßŸã €±€∞ ÿ®ÿßÿ± ÿ™ŸÖÿ±€åŸÜ {hw} ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ.",
            reply_markup=get_main_menu()
        )
        user_state[chat_id] = "completed"
        return

    correct_count = 0
    incorrect_questions = []
    query_results = []

    with engine.begin() as conn:
        for i, student_query in enumerate(queries):
            question_number = i + 1
            try:
                student_rows = conn.execute(text(student_query)).fetchall()
                if major == "ÿ¢ŸÖÿßÿ±":
                    reference_table = f"hw{hw}_q{question_number}_stat_reference"
                else:
                    reference_table = f"hw{hw}_q{question_number}_cs_reference"

                reference_rows = conn.execute(text(f"SELECT * FROM {reference_table}")).fetchall()
                correct = set(student_rows) == set(reference_rows)
                if correct:
                    correct_count += 1
                else:
                    incorrect_questions.append(question_number)
                query_results.append({
                    "question_number": question_number,
                    "student_rows": [list(r) for r in student_rows],
                    "reference_rows": [list(r) for r in reference_rows],
                    "correct": correct
                })
            except Exception as e:
                incorrect_questions.append(question_number)
                query_results.append({
                    "question_number": question_number,
                    "error": str(e),
                    "correct": False
                })

        conn.execute(text("""
            CREATE TABLE IF NOT EXISTS student_results (
                id SERIAL PRIMARY KEY,
                student_id TEXT NOT NULL,
                name TEXT NOT NULL,
                major TEXT NOT NULL,
                hw TEXT NOT NULL,
                correct_count INTEGER NOT NULL,
                submission_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                query_results JSONB
            )
        """))

        conn.execute(
            text("""
                INSERT INTO student_results (student_id, name, major, hw, correct_count, query_results)
                VALUES (:student_id, :name, :major, :hw, :correct_count, :query_results)
            """),
            {
                "student_id": student_id,
                "name": name,
                "major": major,
                "hw": hw,
                "correct_count": correct_count,
                "query_results": query_results
            }
        )

    persian_date, persian_time = get_persian_datetime()

    result_message = f"‚úÖ ÿ™ÿµÿ≠€åÿ≠ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ!\n\n"
    result_message += f"üìÖ ÿ™ÿßÿ±€åÿÆ: {persian_date}\nüïê ÿ≥ÿßÿπÿ™: {persian_time}\n"
    result_message += f"üë§ ÿØÿßŸÜÿ¥ÿ¨Ÿà: {name}\nüÜî ÿ¥ŸÖÿßÿ±Ÿá ÿØÿßŸÜÿ¥ÿ¨Ÿà€å€å: {student_id}\nüìö ÿ±ÿ¥ÿ™Ÿá: {major}\nüìù ÿ™ŸÖÿ±€åŸÜ: {hw}\n\n"
    result_message += f"üìä ŸÜÿ™€åÿ¨Ÿá: {correct_count}/{len(queries)} ÿ≥ŸàÿßŸÑ ÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™.\n\n"

    email_address = "hw@statdb.ir" if major == "ÿ¢ŸÖÿßÿ±" else "hw@dbcs.ir"
    result_message += f"ŸÑÿ∑ŸÅÿßŸã ÿßÿ≤ ÿß€åŸÜ Ÿæ€åÿßŸÖ ÿßÿ≥⁄©ÿ±€åŸÜ ÿ¥ÿßÿ™ ÿ®⁄Ø€åÿ±€åÿØ Ÿà ÿ®Ÿá ÿ¢ÿØÿ±ÿ≥:\n{email_address}\n\n"

    if incorrect_questions:
        result_message += "‚ùå ÿ≥ŸàÿßŸÑ‚ÄåŸáÿß€å ÿßÿ¥ÿ™ÿ®ÿßŸá: " + ", ".join(map(str, incorrect_questions)) + "\n\n"
    else:
        result_message += "üéâ ÿ™ŸÖÿßŸÖ ÿ≥ŸàÿßŸÑ‚ÄåŸáÿß ÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™!\n\n"

    new_submission_count = submission_count + 1
    remaining_attempts = 10 - new_submission_count
    result_message += f"üìà ÿßÿ±ÿ≥ÿßŸÑ‚ÄåŸáÿß€å ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØŸá: {new_submission_count}/10\nüìä ÿ®ÿßŸÇ€å‚ÄåŸÖÿßŸÜÿØŸá: {remaining_attempts}\n\n"
    if remaining_attempts == 0:
        result_message += "‚ö†Ô∏è ÿß€åŸÜ ÿ¢ÿÆÿ±€åŸÜ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ŸÖÿß ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿ™ŸÖÿ±€åŸÜ ÿ®ŸàÿØ.\n\n"
    result_message += "ÿ¢€åÿß ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ™ŸÖÿ±€åŸÜ ÿ¨ÿØ€åÿØ€å ÿ´ÿ®ÿ™ ⁄©ŸÜ€åÿØÿü"

    update.message.reply_text(result_message, reply_markup=get_main_menu())
    user_state[chat_id] = "completed"

# ==================== ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ±ÿ®ÿßÿ™ ====================
updater = Updater(TOKEN, use_context=True)
dp = updater.dispatcher
dp.add_handler(CommandHandler("start", start))
dp.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_message))
dp.add_handler(MessageHandler(Filters.document, handle_document))
updater.start_polling()

# ==================== Ÿàÿ® ÿ≥ÿ±Ÿàÿ± Flask ÿ®ÿ±ÿß€å Keep Alive ====================
app = Flask('')
@app.route('/')
def home():
    return "ÿ±ÿ®ÿßÿ™ ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™ ‚úÖ"

def run():
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port)

Thread(target=run).start()
updater.idle()
